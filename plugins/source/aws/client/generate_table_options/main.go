package main

import (
	"fmt"
	"go/types"
	"os"
	"strings"

	"github.com/cloudquery/plugin-sdk/v2/caser"
	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var skipPackageImports = []string{"time.Time"}

type client struct {
	generatedTypes []string
	f              *jen.File
	caser          caser.Caser
}

func (c *client) addGeneratedType(genType string) {
	c.generatedTypes = append(c.generatedTypes, genType)
}

func (c *client) checkGeneratedType(genType string) bool {
	return contains(c.generatedTypes, genType)
}

func (c *client) loadType(fullDef string) {
	if contains(skipPackageImports, fullDef) {
		return
	}

	sourceType := fullDef
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)
	// 2. Inspect package and use type checker to infer imported types
	pkg := loadPackage(sourceTypePackage)

	// 3. Lookup the given source type name in the package declarations
	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s", sourceTypeName, pkg))
	}

	// 4. We check if it is a declared type
	if _, ok := obj.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%v is not a named type", obj))
	}

	switch v := obj.Type().Underlying().(type) {
	case *types.Struct:
		err := c.generateStruct(sourceTypeName, v)
		if err != nil {
			failErr(err)
		}
	case *types.Basic:
		c.generateString(sourceTypeName)
	}
}

func genPackage(srcPkgUrl, fileName string) error {
	service := strings.Split(fileName, ".")[0] + "_input"
	input := strings.Split(fileName, ".")[1]
	c := &client{
		f:     jen.NewFile(service),
		caser: *caser.New(),
	}
	// 3. Add a package comment, so IDEs detect files as generated
	c.f.PackageComment("Code generated by generator, DO NOT EDIT.")
	c.loadType(srcPkgUrl)
	dir := "../table_option_inputs/" + service + "/"
	targetFilename := input + ".go"
	err := os.MkdirAll(dir, os.ModePerm)
	if err != nil {
		return err
	}
	// 7. Write generated file
	err = c.f.Save(dir + targetFilename)
	if err != nil {
		return fmt.Errorf("writing output: %v", err)
	}
	return nil
}

func main() {
	// 1. Get the package of the file with go:generate comment
	// goPackage := "table_option_inputs"
	srcPkgUrls := []string{
		"github.com/aws/aws-sdk-go-v2/service/costexplorer.GetCostAndUsageInput",
		"github.com/aws/aws-sdk-go-v2/service/inspector2.ListFindingsInput",
		"github.com/aws/aws-sdk-go-v2/service/accessanalyzer.ListFindingsInput",
		"github.com/aws/aws-sdk-go-v2/service/cloudtrail.LookupEventsInput",
	}
	for _, srcPkgUrl := range srcPkgUrls {
		split := strings.Split(srcPkgUrl, "/")
		fileName := split[len(split)-1]
		err := genPackage(srcPkgUrl, fileName)
		if err != nil {
			panic(err)
		}
	}
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.MyType"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func (c *client) generateString(sourceTypeName string) {
	if contains(c.generatedTypes, sourceTypeName) {
		return
	}
	c.addGeneratedType(sourceTypeName)
	c.f.Type().Id(sourceTypeName).String()
}

func contains(s []string, str string) bool {
	for _, v := range s {
		if v == str {
			return true
		}
	}

	return false
}

func (c *client) generateStruct(sourceTypeName string, structType *types.Struct) error {
	if c.checkGeneratedType(sourceTypeName) {
		return nil
	}
	c.addGeneratedType(sourceTypeName)
	var changeSetFields []jen.Code

	// 4. Iterate over struct fields
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		name := field.Name()
		if name == "noSmithyDocumentSerde" {
			continue
		}
		// Generate code for each changeset field
		code := jen.Id(name)
		switch v := field.Type().(type) {
		case *types.Slice:
			switch vNested := v.Elem().(type) {
			case *types.Basic:
				code.Op("[]").Id(vNested.String()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
			case *types.Named:
				typeName := vNested.Obj()
				if typeName.Name() != sourceTypeName {
					c.loadType(typeName.Pkg().Path() + "." + typeName.Name())
				}
				code.Op("[]").Id(typeName.Name()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
			default:
				return fmt.Errorf("struct field type not handled: %T", vNested)
			}
		case *types.Map:
			switch vNested := v.Elem().(type) {
			case *types.Basic:
				code.Op("map[string]").Id(vNested.String()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
			case *types.Named:
				nestedTypeName := vNested.Obj()
				// Qual automatically imports packages
				if nestedTypeName.Name() != sourceTypeName {
					c.loadType(nestedTypeName.Pkg().Path() + "." + nestedTypeName.Name())
				}
				code.Map(jen.Id(v.Key().String())).Id(nestedTypeName.Name()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})

			default:
				return fmt.Errorf("struct field type not handled: %T", vNested)
			}
		case *types.Pointer:
			switch vNested := v.Elem().(type) {
			case *types.Basic:
				code.Op("*").Id(vNested.String()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
			case *types.Named:
				typeName := vNested.Obj()
				// Qual automatically imports packages

				if typeName.Name() != sourceTypeName {
					c.loadType(typeName.Pkg().Path() + "." + typeName.Name())
				}
				path := typeName.Pkg().Path()

				if strings.HasPrefix(path, "github.com/") {
					code.Op("*").Id(typeName.Name()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
				} else {
					code.Op("*").Qual(typeName.Pkg().Path(), typeName.Name()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
				}

			default:
				return fmt.Errorf("struct field type not handled: %T", vNested)
			}

		case *types.Basic:
			code.Op("*").Id(v.String()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
		case *types.Named:
			typeName := v.Obj()
			// Qual automatically imports packages
			c.loadType(typeName.Pkg().Path() + "." + typeName.Name())
			code.Op("*").Id(typeName.Name()).Tag(map[string]string{"json": c.caser.ToSnake(name) + "," + "omitempty"})
		default:
			return fmt.Errorf("struct field type not handled: %T", v)
		}
		changeSetFields = append(changeSetFields, code)
	}

	c.f.Type().Id(sourceTypeName).Struct(changeSetFields...)

	return nil
}
